# 가장 큰 수(다시 풀 필요 있음)
배열이 주어지고 그 안의 원소들을 이어붙여 만들 수 있는 가장 큰 수를 만드는 문제

접근을 어떻게 하는가?

정렬보다는 문자열 처리에 가깝다.

가장 큰 수를 만들려면 높은 자리에 큰 수가 와야한다. 

1. 작은 것부터 먼저 해보자 [6,10,2]를 붙이면 6102가 된다. [2,6,10] ⇒ 2610 [10,6,2]⇒1062 
2. 가장 큰 수는 [6,2,10]⇒6210이다.
3. 맨 앞 자리 수가 가장 큰 것부터 정렬한다. 즉, 숫자 정렬이 아니다.
4. 문자열 정렬을 하면 [6,10,2] ⇒ [6,2,10]이 된다.
5. 2번째 테스트 케이스는 [3,30,34,5,9]이다. 문자열 정렬하면 [9,5,34,30,3]이된다.
6. 하지만 가장 큰 수는 [9,5,34,3,30]으로 마지막 두 원소가 바뀌어야 성공이다.
7. 자바스크립트에서 정렬을 커스터마이징할 수 있다. 
8. arr.sort((a,b)⇒a-b)이런식으로 커스터마이징을 할 수 있다.

나는 여기서 막혔다. 303을 330으로 바꾸기위해서는 어떻게 해야하는지 몰랐다.

어떻게하면 문자열 연산으로 (b+a) -  (a+b) 가 양수인 경우에만 정렬하도록 하는 생각을 할까?

두번째 방법은 강제로 네 자리 수를 만들어 비교한다고 한다. 제약사항에 0에서1000까지의 정수이므로 최대 값이 1000이다. 제약조건에 중심을 둔 방법이다.

지금 생각으로는 아무 논리도 없이 네자리로 만들어 비교하는 것 같다. 네자리로 만드는 이유가 무엇일까?

이 분도 303과 330의 예외 경우를 직면했다. 이 경우를 처리하기 위해서 언제 한자릿수가 그보다 큰 자릿수의 수보다 우선순위가 높은지를 알아야한다고 생각했다고 한다. 언제 3이 30보다 우선순위가 높은지를 알아야한다. 이 생각은 어떻게 나온 것일까? 예외가 생긴 이유는 30이 3보다 우선순위가 높게 나왔기 때문이다. 왜 30이 3보다 우선순위가 높게 나왔을까를 생각하면 언제 30이 3보다 우선순위가 높은지로 자연스럽게 생각이 이어진다. 

즉, 예외가 나왔을 때 왜 그것이 나왔을까를 생각하고 분기하기위해 언제 그것이 나왔는지 생각해보는 것이 중요하다.

그럼 언제 30이 3보다 우선순위가 높게 나올까? 이미 정답을 알지만 이 질문의 답은 모른다. 

생각해보면 문자열 정렬은 2가 10보다 우선순위가 높다. 하지만 3은 30보다 우선순위가 낮다 그 이유는 아스키코드와 관계가 있을 것으로 예상된다.

숫자의 경우에는 10과 2는 아스키코드 값이 10이 더 크다.  하지만 문자열 10과 2는 2가 더 크다.

문자 비교는 앞글자의 아스키코드 값의 비교로 이루어진다. 문자열 10과 2의 아스키 코드 값은 맨 앞글자 1과 2의 아스키 코드 비교로 이어진다. 1은 49 2는 50번이다. 따라서 2가 더 우위에 있다. 

반면 3과 30을 비교하면 맨 앞글자 3은 둘 다 동일하게 51이므로 비교할 수 없다. 그럼 어떻게 비교할까?

뒤져봐도 없다... Null의 아스키 코드 값은 0 이고 0의 아스키코드 값은 48이다. 맨 앞글자를 비교했으니 두번째 글자를 비교한 것인건지... 잘모르겠지만 어쨌든 콘솔로도 찍어보면 '30'>'3' ⇒ true '30'<'3'⇒ false가 나온다...

그럼 일단 문자열 비교를 통해 맨 앞의 숫자가 같은 경우에는 뒤에 있는 숫자로 비교한다고 가정하고 문제를 계속해서 해결해보자 (잠깐 '309'< '310'⇒ true가 나오는 것을 보아 가정이 맞는 것 같다.)

언제 큰 자릿수의 숫자가 작은 자릿수의 숫자보다 우선순위가 높은가?

- 맨 앞자리 수가 클경우 ('500'>'10')
- 같아도 그 뒤의 숫자가 큰 경우 ('30'>'3') 0은 아무것도 없는 것보다 크다.

언제 우선순위가 높은지 알았다. 그래도 왜 네자리 수로 만들어서 비교하는지는 아직 연결점을 찾지 못했다.

네자리로 만들 수 있다는 것을 알고는 우선순위가 높은 것을 알 수 있었지만 우선순위가 높다해서 네자리로 맞추는 생각은 저절로 떠오르지 않는 이상 어떻게 저런 방법을 생각하는 지 알 수 없다. 

네 자리로 만들어 비교를 하면 원하는 대로 비교할 수 있다는 것을 안다고 가정하고 설명하면 3030<3333이다. 

만약 저대로 정렬을 한 경우 중 맨 앞의 숫자가 0이된다면 뒤의 모든 원소도 0이므로 비교를 할 수 없이 다 똑같다.

그 경우는 제외를 해 주어야한다. 

```jsx
function solution(numbers) {
    var answer = '';
    (a,b)=>(b+a)-(a+b));
    numbers[0]==='0'? answer += 0 : answer = numbers.join("")
    return answer;
}

```
